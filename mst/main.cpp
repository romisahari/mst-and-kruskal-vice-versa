#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5;
int n, m, en1[maxn], en2[maxn];
bool mrk[maxn], mrk_v[maxn];
vector < pair<int, int> > adj[maxn];
pair<int, int> e[maxn];

void dfs(int v){
      mrk_v[v] = true;
      //راس جدید که به آن وارد شدیم را علامت میزنیم
      for(int i = 0; i < (int)adj[v].size(); i ++){ //روی تمام همسایه های راس جدید فور میزنیم
            if(mrk[ adj[v][i].second ] == true){
                  //اگر یال متصل به این همسایه علامتش خورده بود یعنی جزو یال هایی است که حذف شده
                  //پس این یال را نباید استفاده کنیم پس با کانتینیو به آی بعدی در فور میرویم
                  continue;
            }
            int u = adj[v][i].first;
            // اگر یال مورد نظر که همسایه ی راس جدید را وارد میکرد مارک نشده بود پس این همسایه میتواند بیاید
            //اگر همسایه ی مورد نظر قبلا توسط دی اف اس دیده نشده بود پس آن را صدا میکنیم
            if(!mrk_v[u]){
                  dfs(u);
            }
      }
      //اردر دی اف اس = n + m
      //ما هر بار تابع دی اف اس را در بازگشتی فقط زمانی صدا میکنیم که راس مارک نشده باشد
      //پس در یک سری دی اف اس زدن قبل از اینکه کل ارایه ی مارک را 0 کنیم به ازای هر راس حداکثر یک بار دی اف اس ران میشود
      //داخل این تابع روی همسایه های راس مورد نظر یک فور زدیم
      //به ازای هر راس یک دور روی تمام همسایه های ان فور زدیم پس هر یال حداکثر دو بار دیده شده پس در کل به اندازه ی تعداد یال ها به علاوه ی رعوس یک بار دی اف اس زدن اردر دارد
      // پس اردر یک بار ران کردن dfs = n + m
      return;
}

bool check_connect(){
      //اردر این تابع برابر است با:
      //n + اردر dfs + n   => 3n + m => n + m
      int cnt = 0;
      for(int i = 1; i <= n; i ++){
            mrk_v[i] = false;
            //برای دی اف اس مارک دیدن همه ی راس هارا 0 میکنیم
      }
      dfs(1);
      //از یک راس دلخواه دی اف اس میزنیم
      //دی اف اس یک زیر درخت فراگیر در گراف که راس 1 توش توش باشد را میدهد
      //در حین دی اف اس تمام راس هایی که دیده ایم را مارکشان را 1 کرده ایم
      //اگر گراف همبند باشد پس زیر درخت فراگیری که راس 1 توش باشه تمام راس هارا شامل میشود
      //پس اگر راسی مارک آن 1 نشده بود پس گراف ناهمبند شده است و در فور پایین این را چک میکنیم
      for(int i = 1; i <= n; i ++){
            if(mrk_v[i] == false){
                  return false;
            }
      }
      return true;
}

int main(){
      cout <<"give me the graph size and number of edges" <<endl;
      cin >>n >>m;
      cout <<"for each edge give me the end pointes and the weight" <<endl;
      for(int i = 0; i < m; i ++){
            cin >>en1[i] >>en2[i] >>e[i].first;
            int u = en1[i], v = en2[i];
            e[i].second = i; //یال های گراف رو به صورت پیر مقدار یال و اندیس ان ذخیره میکنیم
            adj[u].push_back(make_pair(v, i)); //به ازای هر راس تمام همسایه های ان را ذخیره میکنیم
            adj[v].push_back(make_pair(u, i)); //با اضافه شدن یال جدید همسایگی دو سر یال اپدیت میشوند
            //اندیس یال و همچنین راسی که این راس با این یال به ان متصل شده است را در همسایگی راس ها ذخیره میکنیم
            //با ماتریس مجاورت هم میشود ولی خب اینجوری اردر به اندازه ی تعداد یال هاست
            // ولی با ماتریس مجاورت اردر در هر صورت اندازه ی ماکسیسمم تعداد یال ها یعنی n**2
      }
      sort(e, e + m);
      int ans = 0;
      cout <<"the mst edges are :" <<endl;
      for(int i = m - 1; i >= 0; i --){
            int x = e[i].second;  //اندیس یال مورد نظر را در ایکس میریزیم
            mrk[x] = true; //یال را علامت گذاری میکنیم به این معنا که حذف شده است
            if(check_connect() == false){  //اگر بعد از حذف شدن دیسکانکت شده بود این یال را انتخاب میکنیم و برمیگردانیم

                  mrk[x] = false;
                  cout <<en1[x] <<' ' <<en2[x] <<endl;
                  ans += e[i].first;
            }
      }
      cout <<"mst weight is : " <<ans <<endl;
      return false;
}
